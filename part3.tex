\documentclass[aspectratio=169]{beamer}

\usepackage[utf8]{inputenc}
\usepackage{soul}
\usepackage{pdfpcnotes}
\usepackage{listings}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{minted}
\usepackage[ngerman]{babel}

\usetheme{Hannover}
\usecolortheme{dove}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\lstset{language=C++,
                basicstyle=\ttfamily,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{purple}\ttfamily,
                morecomment=[l][\color{magenta}]{\#}
}


\title{Eine Einführung in modernes C++}
\subtitle{Teil 3 -- Unittest, Tools und best practices}
\author{Paul Nykiel}
\date{\today}

\begin{document}
\maketitle

\frame{
    \pnote{Sofort Fragen!}
    \pnote{Feedback erwünscht}
    \tableofcontents
}

\section{Unittests}
\begin{frame}
    \frametitle{Was sind Unittests?}
    \begin{itemize}
        \item Möglichst kleine Komponenten des Codes testen (z.B. einzelne Funktion/Klasse)
            \pnote{Auf dieser Ebene noch möglich Korrektheit zu bestätigen}
            \pause
        \item Nicht komplette Codebase notwendig
            \pnote{z.B. kein ADTF, Edgecases müssen nicht in echter Welt konstruiert werden}
            \pause
        \item Restlicher Code kann auf Korrektheit vertrauen
            \pnote{Vertrauen auf Model, selbst bei Änderungen} 
            \pause
        \item Vorgehen: Festdefinierte Eingabe und daraus resultierende Ausgabe
            \pnote{Entwickler definiert Eingabe und was resultat sein muss}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Google Test - Einführung}
    \begin{itemize}
        \item Tests von einem Modul werden in einer Testsuite zusammengefasst
            \pnote{D.h. eine Testsuite für Funktion A, eine für Funktion B}
            \pause
        \item Innerhalb einer Testsuite können beliebig viele Tests angelegt werden
            \pnote{Pro Test ein Name}
            \pause
        \item Jeder Test sollte genau eine Funktionalität prüfen
            \pnote{Dann kann sofort erkannt werden was nicht funktioniert, Tests bleiben kompakt}
            \pause
        \item Bedingungen mit Makros testen
            \pnote{Z.B. Gleichheit, größer, keine Exception...}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Google Test - Funktionen}
    \lstinputlisting{examples/slides/gtest1.cpp}
    \pnote{Diverseste Bedinungen, z.B. auch Float, integration in CLion}
\end{frame}

\begin{frame}
    \frametitle{Google Test - Klassen}
    \lstinputlisting{examples/slides/gtest2.cpp}
    \pnote{Diverseste Bedinungen, z.B. auch Float, integration in CLion}
\end{frame}

\section{Tools}
\begin{frame}
    \Huge{Demo: Debugger}
    \pnote{Einfach Average Implementierung, Breakpoints und Variablen zeigen, Hinweis: auch bei Abstürzen}
\end{frame}

\begin{frame}
    \Huge{Demo: Valgrind}
    \pnote{Einfachen Memory Leak bauen, vllt. Use After Free}
\end{frame}

\begin{frame}
    \Huge{Demo: clang-tidy}
    \pnote{Vorheriges Beispiel: Warnings anzeigen, und fixen}
\end{frame}

\section{Best Practices}
\begin{frame}
    \frametitle{Allgemein}
    Auskommentierter Code, Warnings, Sichtbarkeit, Duplicate Code,
    Keine einzeiligen ifs, Magic Numbers
\end{frame}

\begin{frame}
    \frametitle{Funktionen}
    In, In-Out, Out-Parameter, Tuple als Return, Structure Bindings, Optional
\end{frame}

\begin{frame}
    \frametitle{C-Konstrukte}
    Raw Pointer, Array, Enum, Makros
\end{frame}

\begin{frame}
    \frametitle{Formatierung}
    Include Guards, Endung, Alle Header inkludieren, eigene Translation Unit
\end{frame}

\section{Abschluss}
\begin{frame}
    \frametitle{Was fehlt?}
    \begin{itemize}
        \item R-Value Referenzen, forward/universal Referenzen
            \pnote{Neue Form von Referenz (ab C++11), primär benötigt wenn nicht triviale Speicherverwaltung}
            \pause
        \item Move
            \pnote{Speicher von einer Klasse an eine andere Übergeben, z.B. return, per default da, sonst wenn nicht triviale Speicherverwaltung}
            \pause
        \item Destruktor und Copy / Move Konstruktor
            \pnote{Wird per default angelegt, muss nur angelegt werden wenn nicht trivialer Speicher verwaltet wird}
            \pause
        \item Operatorenüberladung
            \pnote{Nur spezielle Member Funktionen, einfach!}
            \pause
        \item Friend Definition
            \pnote{Wird selten benötigt, einfach einzulesen}
            \pause
        \item Meta-Programming
            \pnote{Touring-vollständige Sprache zur CompileTime, type\_traits, bringt zwar Vorteile aber nicht notwendig}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Mehr Informationen}
    \begin{itemize}
        \item \url{en.cppreference.com}
            \pnote{Dokumentation der Sprache und STL, deutsche Version ist Shit}
            \pause
        \item \url{github.com/isocpp/CppCoreGuidelines}
            \pnote{Gut für Designentscheidungen}
            \pause
        \item \url{godbolt.org}
            \pnote{Was erzeugt der Compiler für Code auf unterschiedlichen Plattformen, eher als Spielzeug}
            \pause
        \item \url{git.spatz.wtf/spatzenhirn/cppcmakeintro}
            \pnote{Dieser Vortrag}
            \pause
        \item Scott Meyers: Effective Modern C++
            \pnote{Gutes Buch, deutliche Vertiefung}
    \end{itemize}
\end{frame}

\section{Praxis}
\begin{frame}
    \frametitle{Praxis}
    \begin{itemize}
        \item Schreibt Unittests für den Huffman Encoder
            \pause
        \item Untersucht das Verhalten: meldet Valgrind Probleme? meldet clang-tidy welche?
            \pause
        \item Lest euch die Code-Richtlinien (\url{https://git.spatz.wtf/spatzenhirn/wiki/-/wikis/Software/Cup2021/CodeRichtlinien}) durch und überprüft ob euer Code die Richtlinien erfüllt.
    \end{itemize}
\end{frame}


\end{document}
